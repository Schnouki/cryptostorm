#!/usr/bin/with-contenv bash

CY="\e[1;33m" # yellow
CDM="\e[0;35m" # magenta
CN="\e[0m"    # none

SLOWEXIT()
{
  local code
  code="$1"

  shift 1
  echo -e "[${CY}ERROR${CN}] $*"
  sleep 10
  exit "$code"
}

WARN()
{
  echo -e "[${CY}WARN${CN}] $*"
}


# auto_select_server <position>
#   Select the nearest server. Position can 0, 1, 2, .. for
#     the 1st, 2nd, 3rd, ...server in the list.
#   Set SERVER, END_POINT, EP_IP and EP_PORT
# Note: Should only be called if WireGuard is DOWN
# Note: I wish CS would provide an API to request nearest server and
#       configuration based on my current IP location. This is mad...
auto_select_server()
{
  local pos
  local str
  local ep
  local name
  local servers
  local hosts
  local ports

  echo "[+] Picking fastest server...."
  unset SERVER
  unset EP_IP
  unset EP_PORT

  pos="$1"
  [[ -z $pos ]] && pos=0

  # At the moment END_POINT are all <name>.cstorm.is but this may change...
  # Better read END_POINT from the config file...
  local h
  local p
  for cf in $(cd /etc/wireguard; echo cs*.conf); do
    name="${cf//cs-/}"
    name="${name//\.conf/}"
    [[ -z $name ]] && continue

    str="$(grep ^Endpoint "/etc/wireguard/${cf}")"
    str="${str##* }"
    p="${str##*\:}"
    h="${str%%\:*}"
    [[ -z $h ]] && continue
    hosts+=("${h}")
    ports+=("${p}")
    servers+=("${name}")
  done

  # hosts=("atlanta.cstorm.is" "austria.cstorm.is" "noexist.thc" "barcelona.cstorm.is")
  unset res

  # Use size 42 (20 IP + 8 ICMP + 42 Payload == 70)
  iptables -A OUTPUT -o eth0 -p icmp -m length --length 70 -j ACCEPT
  readarray -t res < <(fping -c5 -4 -q -b 42 "${hosts[@]}" 2>&1)
  iptables -D OUTPUT -o eth0 -p icmp -m length --length 70 -j ACCEPT

  # Return if we didnt get any results...
  [[ ${#res[@]} -le 0 ]] && { WARN "No results from any server. Firewalled?"; return; }

  # If one of the hosts did not resolve then its discarded from
  # the result list. Thus we need to match them all up again
  local n
  local max
  local avg
  local arr
  n=0
  unset arr
  while [[ $n -lt "${#res[@]}" ]]; do
    str="${res[$n]}"
    ((n++))
    loss="${str%\%*}"
    loss="${loss##*/}"
    [[ $loss -gt 20 ]] && continue # more than 1 packet got lost.
    name="${str%% *}"
    max="${str##*/}"
    str="${str%/*}"
    avg="${str##*/}"
    # Arrange so that average is first (for sort -n)
    arr+=("$avg $name")
  done

  # All have packet loss?
  [[ ${#arr[@]} -le 0 ]] && { WARN "Could not ping any server. Firewalled?"; return; }

  # Sort list and store in array
  unset sorted
  readarray -t sorted < <(shuf -e "${arr[@]}" | sort  -n)

  # Need to match up sorted list's hostnames with the original
  # list of hosts (positions)
  n=0
  unset pos_arr
  while [[ $n -lt ${#sorted[@]} && $n -le $pos ]]; do
    str="${sorted[$n]}"
    str="${str##* }"
    ((n++))
    # Find this host in our hosts array
    i=0
    while [[ $i -lt ${#hosts[@]} ]]; do
      host="${hosts[$i]}"
      [[ "$host" == "$str" ]] && { pos_arr+=("$i"); break; }
      ((i++))
    done
  done

  # See if POS is beyond end of array
  [[ $pos -ge ${#pos_arr[@]} ]] && { WARN "Server #${pos} not found. Only ${#pos_arr[@]} available."; return; }

  n=${pos_arr[$pos]}
  SERVER="${servers[$n]}"
  h="${hosts[$n]}"
  END_POINT="${h}"
  [[ -n ${ports[$n]} ]] && END_POINT+=":${ports[$n]}"

  str=$(host -4 "${hosts[$n]}" | grep -v IPv6 | head -n1)
  EP_IP="${str##* }"
  EP_PORT="${END_POINT##*\:}"
  EP_PORT="${EP_PORT:-51820}"
  echo -e "[+] Using ${CDM}${h}${CN} (${EP_IP}:${EP_PORT})"
}

str="$CRYPTOSTORM_CONFIG"
[[ -z $SERVER ]] && SERVER="${str%%:::*}"
str="${str#*:::}"
[[ -z $PRIVATE_KEY ]] && PRIVATE_KEY="${str%%:::*}"
str="${str#*:::}"
[[ -z $PSK ]] && PSK="${str%%:::*}"
[[ -z $ADDRESS ]] && ADDRESS="${str#*:::}"

[[ -z $ADDRESS ]] && ERREXIT "Bad Config."

# If SERVER is AUTO or EMPTY then auto-select a server...
[[ "${SERVER,,}" == "auto" ]] && unset SERVER
[[ -z "${SERVER}" ]] && auto_select_server
[[ -z ${SERVER} ]] && SLOWEXIT 249 "No Server found..."

cf="/etc/wireguard/cs-${SERVER}.conf"

[[ ! -f "${cf}" ]] && {
  echo -e "Server '${SERVER}' not known."
  cd /etc/wireguard
  str="$(echo cs-*.conf)"
  str="${str//cs-/}"
  NODES="${str//\.conf/}"
  echo -e "--> Try one of ${NODES}"
  sleep 10
  exit
}

[[ -z $END_POINT ]] && {
  str="$(grep ^Endpoint "${cf}")"
  END_POINT="${str##* }"
  [[ -z $END_POINT ]] && SLOWEXIT 250 "${cf}: No Endpoint found"
}

[[ -z $PUBLIC_KEY ]] && {
  str="$(grep ^PublicKey "${cf}")"
  PUBLIC_KEY="${str##* }"
  [[ -z $PUBLIC_KEY ]] && SLOWEXIT 250 "${cf}: No PublicKey found"
}

[[ $(sysctl net.ipv4.ip_forward -b) -ne 1 ]] && WARN "ip_forward= not set"
[[ $(sysctl net.ipv4.conf.all.src_valid_mark -b) -ne 1 ]] && WARN "net.ipv4.conf.all.src_valid_mark= not set"

# Allow WireGuard traffic to the endpoint. Alpine's 'host -4' still returns IPv6 as well..

[[ -z $EP_IP ]] && {
  str=$(host -4 "${END_POINT%%\:*}" | grep -v IPv6)
  EP_IP="${str##* }"
  EP_PORT="${END_POINT##*\:}"
}
EP_PORT="${EP_PORT:-51820}"
[[ -z $EP_IP ]] && SLOWEXIT 250 "EP_IP not set..."
iptables -A OUTPUT -o eth0 -p udp -m udp -d "${EP_IP}" --dport "${EP_PORT}" -j ACCEPT
# ip6tables -A OUTPUT -o eth0 -p udp -m udp --dport 51820 -j ACCEPT

( umask 077 && { cat >/etc/wireguard/wg0.conf <<-EOF
[Interface]
PrivateKey = ${PRIVATE_KEY}
Address = ${ADDRESS}
DNS = ${DNS:-1.1.1.1}
Table = ${TABLE}
PreUp = ${PRE_UP}
PostUp = ${POST_UP}
PreDown = ${PRE_DOWN}
PostDown = ${POST_DOWN}

[Peer]
Presharedkey = ${PSK}
PublicKey = ${PUBLIC_KEY}
Endpoint = ${EP_IP}:${EP_PORT}
AllowedIPs = ${ALLOWED_IPS:-0.0.0.0/0}
PersistentKeepalive = ${PERSISTENT_KEEP_ALIVE:-25}
EOF
} && sync )

wg-quick up wg0
n=0
while :; do
  last=$(wg show wg0 latest-handshakes 2>/dev/null)
  last="${last##*[[:space:]]}"
  [[ $last -gt 0 ]] && break

  ((n++))
  [[ $n -gt 20 ]] && SLOWEXIT 0 "Timeout..."
  sleep 0.5
done

echo "[$(date -Iseconds)] Connected! \(ᵔᵕᵔ)/"

if [[ -n ${RECONNECT} ]]; then
  echo "[$(date -Iseconds)] Reconnecting in ${RECONNECT} seconds"
  re=$RECONNECT
fi
n=0
while :; do
  last=$(wg show wg0 latest-handshakes 2>/dev/null)
  last="${last##*[[:space:]]}"

  [ -z "$last" ] && break

  hs_age=$(( $(date -u +%s) - "${last}" ))
  if [ $hs_age -le 180 ]; then
    [ $n -gt 0 ] && echo "[$(date -Iseconds)] Re-Handshake complete!"
    n=0
  else
    ((n++))
    echo -e "[$(date -Iseconds)] Strike #${n}: No handshake for $hs_age sec..."
    [ $n -gt 3 ] && break
  fi
  sleep 10
  [[ -n $RECONNECT ]] && {
    re=$((re - 10))
    [ $re -le 0 ] && break
  }
done

echo "[$(date -Iseconds)] RESTARTING..."
sleep 5
